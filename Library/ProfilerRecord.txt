#pragma once 

// Profiler.h 

using std::vector;
using std::string;
using std::unordered_map;
using std::pair;
using std::cout;
using std::cerr;

namespace Profiler {
	enum Unit {
		NANOSEC, //  nanoseconds 
		MCROSEC, // microseconds 
		MILISEC, // milliseconds 
		SEC, //      seconds 
	};
	constexpr const char* UnitStr[] = { "ns", "us", "ms", " s" };
	static LARGE_INTEGER _frequency;

	static void InitProfiler() noexcept {
		QueryPerformanceFrequency(&_frequency);
	}

	inline static const long long Frequency() noexcept {
		return _frequency.QuadPart;
	}

	inline static const long double GetUnitMultiplier
	(Profiler::Unit unit) noexcept {
		switch (unit) {
		case Profiler::NANOSEC: return 1'000'000'000.0L;
		case Profiler::MCROSEC: return 1'000'000.0L;
		case Profiler::MILISEC: return 1'000.0L;
		case Profiler::SEC: return 1.0L;
		}
		return 1.0L;
	}

	// Singleton Manager 
	class Manager {
	private:
		Manager() noexcept { InitProfiler(); }
		~Manager() noexcept = default;
		Manager(const Manager&) = delete;
		Manager& operator=(const Manager&) = delete;

	private:
		typedef struct _Data {
			long long init;
			long long term;
		} Data;
		unordered_map<const char*, vector<Data>> _func_map;

	public:
		static Manager& GetInstance() noexcept
		{
			thread_local Manager instance;
			return instance;
		}

		inline void ClearData() noexcept {
			_func_map.clear();
		}

		void AddProfile(const char* section_name, long long init, long long term) noexcept;
		void PrintConsoleTick() const noexcept;
		void PrintConsoleTime(Unit unit) const noexcept;

		void SaveDataTXT(const string& filepath, Unit unit) noexcept;
		void SaveDataCSV(const string& filepath, Unit unit) noexcept;
		void SaveFuncCSV(const string& filepath) noexcept;
	};

	class EnterSection {
	private:
		bool _finish;
		const char* _section_name;
		LARGE_INTEGER _time_init;

	public:
		EnterSection(const char* section_name) noexcept;
		void LeaveSection() noexcept;
		~EnterSection() noexcept;
	};
}

// ============================================================ 

#include "pch.h"

#include "profiler.h"

// Profiler.cpp 

void Profiler::Manager::AddProfile
(const char* section_name, long long init, long long term) noexcept
{
	auto itr = _func_map.find(section_name);
	if (itr == _func_map.end()) {
		_func_map[section_name] = { {init, term} };
	}
	else {
		_func_map[section_name].push_back({ init, term });
	}
}

void Profiler::Manager::PrintConsoleTick() const noexcept
{
	QueryPerformanceFrequency(&_frequency);
	// long double frequency = static_cast<long double>(_frequency.QuadPart);

	printf("----------------------------------\n");
	for (const auto& pair : _func_map) {
		const char* func_name = pair.first;
		const vector<Data>& data = pair.second;
		if (data.empty()) continue;

		long long total_time_raw = 0;
		long long min_time_raw = LLONG_MAX;
		long long max_time_raw = LLONG_MIN;

		for (auto& datus : data) {
			// printf("%llu ", tick_row); 
			long long tick_row = datus.term - datus.init;
			total_time_raw += tick_row;
			if (tick_row < min_time_raw) min_time_raw = tick_row;
			if (tick_row > max_time_raw) max_time_raw = tick_row;
		}

		printf("Function %s Calls : %zu\n", func_name, data.size());
		printf("Frequency    : %11lld ticks/sec \n", _frequency.QuadPart);
		printf("Total Ticks  : %11lld \n", total_time_raw);
		printf("Min Ticks    : %11lld \n", min_time_raw);
		printf("Max Ticks    : %11lld \n", max_time_raw);
		printf("----------------------------------\n");
	}
}

void Profiler::Manager::PrintConsoleTime(Unit unit) const noexcept {
	long double multiplier = GetUnitMultiplier(unit);
	const char* unit_str = UnitStr[unit];
	QueryPerformanceFrequency(&_frequency);
	long double frequency = static_cast<long double>(_frequency.QuadPart);

	if (frequency == 0.0L) {
		printf("Error: Performance counter frequency is zero. Cannot calculate time.\n");
		return;
	}

	printf("----------------------------------\n");
	for (const auto& pair : _func_map) {
		const char* func_name = pair.first;
		const std::vector<Data>& data = pair.second;
		if (data.empty()) continue;

		long long total_time_raw = 0;
		long long min_time_raw = LLONG_MAX;
		long long max_time_raw = LLONG_MIN;


		for (auto& datus : data) {
			long long tick_row = datus.term - datus.init;
			total_time_raw += tick_row;
			if (tick_row < min_time_raw) min_time_raw = tick_row;
			if (tick_row > max_time_raw) max_time_raw = tick_row;
		}

		long double total_time = static_cast<long double>(total_time_raw) / frequency * multiplier;
		long double avg_time = total_time / data.size();
		long double min_time = static_cast<long double>(min_time_raw) / frequency * multiplier;
		long double max_time = static_cast<long double>(max_time_raw) / frequency * multiplier;

		printf("Function %s Calls : %zu\n", func_name, data.size());
		printf("Total Time   : %16.4Lf %s \n", total_time, unit_str);
		printf("Average Time : %16.4Lf %s \n", data.size() > 0 ? avg_time : 0.0L, unit_str);
		printf("Min Time     : %16.4Lf %s \n", min_time, unit_str);
		printf("Max Time     : %16.4Lf %s \n", max_time, unit_str);
		printf("----------------------------------\n");
	}
}

void Profiler::Manager::SaveDataTXT(const string& filepath, Unit unit) noexcept
{
	FILE* fp = nullptr;
	fopen_s(&fp, filepath.c_str(), "w");
	if (fp == nullptr) {
		cerr << "Error: Unable to open file " << filepath << " for writing.\n";
		return;
	}
	long double multiplier = GetUnitMultiplier(unit);
	const char* unit_str = UnitStr[unit];
	QueryPerformanceFrequency(&_frequency);
	long double frequency = static_cast<long double>(_frequency.QuadPart);
	if (frequency == 0.0L) {
		fprintf(fp, "Error: Performance counter frequency is zero. Cannot calculate time.\n");
		fclose(fp);
		return;
	}
	fprintf(fp, "----------------------------------\n");
	for (const auto& pair : _func_map) {
		const char* section_name = pair.first;
		const std::vector<Data>& data = pair.second;
		if (data.empty()) continue;
		long long total_time_raw = 0;
		long long min_time_raw = LLONG_MAX;
		long long max_time_raw = LLONG_MIN;
		for (auto& datus : data) {
			// printf("%llu ", tick_row);
			long long tick_row = datus.term - datus.init;
			total_time_raw += tick_row;
			if (tick_row < min_time_raw) min_time_raw = tick_row;
			if (tick_row > max_time_raw) max_time_raw = tick_row;
		}
		long double total_time = static_cast<long double>(total_time_raw) / frequency * multiplier;
		long double avg_time = total_time / data.size();
		long double min_time = static_cast<long double>(min_time_raw) / frequency * multiplier;
		long double max_time = static_cast<long double>(max_time_raw) / frequency * multiplier;
		fprintf(fp, "Function %s Calls : %zu\n", section_name, data.size());
		fprintf(fp, "Total Time   : %16.4Lf %s \n", total_time, unit_str);
		fprintf(fp, "Average Time : %16.4Lf %s \n", data.size() > 0 ? avg_time : 0.0L, unit_str);
		fprintf(fp, "Min Time     : %16.4Lf %s \n", min_time, unit_str);
		fprintf(fp, "Max Time     : %16.4Lf %s \n", max_time, unit_str);
		fprintf(fp, "----------------------------------\n");
	}
	fclose(fp);
}

void Profiler::Manager::SaveDataCSV(const string& filepath, Unit unit) noexcept
{
	std::ofstream ofs(filepath);
	if (!ofs.is_open()) {
		cerr << "Error: Unable to open file " << filepath << " for writing.\n";
		return;
	}

	long double multiplier = GetUnitMultiplier(unit);
	const char* unit_str = UnitStr[unit];
	long double frequency = static_cast<long double>(_frequency.QuadPart);
	if (frequency == 0.0L) {
		ofs << "Error: Performance counter frequency is zero. Cannot calculate time.\n";
		ofs.close();
		return;
	}

	ofs << "Function,Calls,Total Time (" << unit_str << "),Average Time ("
		<< unit_str << "),Min Time (" << unit_str << "),Max Time (" << unit_str << ")\n";

	for (const auto& pair : _func_map) {
		const char* func_name = pair.first;
		const std::vector<Data>& data = pair.second;

		long long total_time_raw = 0;
		long long min_time_raw = LLONG_MAX;
		long long max_time_raw = LLONG_MIN;
		for (auto& datus : data) {
			long long tick_row = datus.term - datus.init;
			total_time_raw += tick_row;
			if (tick_row < min_time_raw) min_time_raw = tick_row;
			if (tick_row > max_time_raw) max_time_raw = tick_row;
		}
		long double total_time = static_cast<long double>(total_time_raw) / frequency * multiplier;
		long double avg_time = total_time / data.size();
		long double min_time = static_cast<long double>(min_time_raw) / frequency * multiplier;
		long double max_time = static_cast<long double>(max_time_raw) / frequency * multiplier;
		ofs << func_name << "," << data.size() << ","
			<< total_time << ","
			<< (data.size() > 0 ? avg_time : 0.0L) << ","
			<< min_time << ","
			<< max_time << "\n";
	}
}

void Profiler::Manager::SaveFuncCSV(const string& filepath) noexcept
{
	std::ofstream ofs(filepath);
	if (!ofs.is_open()) {
		cerr << "Error: Unable to open file " << filepath << " for writing.\n";
		return;
	}
	QueryPerformanceFrequency(&_frequency);
	long double frequency = static_cast<long double>(_frequency.QuadPart);
	if (frequency == 0.0L) {
		ofs << "Error: Performance counter frequency is zero. Cannot calculate time.\n";
		ofs.close();
		return;
	}
	ofs << "Function,Count,init,term,time\n";
	for (const auto& pair : _func_map) {
		const std::string& func_name = pair.first;
		const std::vector<Data>& data = pair.second;
		for (size_t i = 0; i < data.size(); ++i) {
			ofs << func_name << "," << (i + 1) << "," << data[i].init << "," << data[i].term << ',' << data[i].term - data[i].init << "\n";
		}
	}
}

Profiler::EnterSection::EnterSection(const char* section_name) noexcept
	: _section_name(section_name), _finish(false), _time_init()
{
	QueryPerformanceCounter(&_time_init);
}

void Profiler::EnterSection::LeaveSection() noexcept {
	if (_finish) return;
	LARGE_INTEGER time_term;
	QueryPerformanceCounter(&time_term);
	// long long elapsed_time = time_term.QuadPart - _time_init.QuadPart;
	Manager::GetInstance().AddProfile(_section_name, _time_init.QuadPart, time_term.QuadPart);
	_finish = true;
}

Profiler::EnterSection::~EnterSection() noexcept
{
	if (_finish) return;
	LARGE_INTEGER time_term;
	QueryPerformanceCounter(&time_term);
	// long long elapsed_time = time_term.QuadPart - _time_init.QuadPart;
	Manager::GetInstance().AddProfile(_section_name, _time_init.QuadPart, time_term.QuadPart);
}
