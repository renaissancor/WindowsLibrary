// SPSCQueue.h 
#pragma once 

#include <wtypes.h>

template<typename T>
class SPSCQueue {
private:
	constexpr static const size_t CACHE_LINE_SIZE = 64; 
	alignas(CACHE_LINE_SIZE) volatile size_t _head{ 0 };
	alignas(CACHE_LINE_SIZE) volatile size_t _tail{ 0 };
	T* _buffer;
	size_t _capacity;

public:
	explicit SPSCQueue(size_t capacity) 
		: _capacity(capacity) 
	{
		_buffer = new T[capacity]; 
	}

	~SPSCQueue() {
		delete[] _buffer; 
	}

	bool Push(const T& item);
	bool Pop(T& item);
	const T* Front(); 
	const T* PopPtr(); 
}; 

// Only Single Producer Thread Calls Push 
template<typename T>
bool SPSCQueue<T>::Push(const T& item) {
	const size_t current_head = _head;
	const size_t current_tail = _tail;
	const size_t next_tail = (current_tail + 1) % _capacity;
	if (next_tail == current_head) {
		return false;
	}
	_buffer[current_tail] = item;
	MemoryBarrier();
	_tail = next_tail;
	return true;
}

// Only Single Consumer Thread Calls Pop 
template<typename T>
bool SPSCQueue<T>::Pop(T& item) {
	const size_t current_head = _head;
	const size_t current_tail = _tail;
	MemoryBarrier();
	if (current_head == current_tail) {
		return false;
	}
	item = _buffer[current_head];
	const size_t next_head = (current_head + 1) % _capacity;
	
	_head = next_head; 
	return true;
}

template<typename T>
const T* SPSCQueue<T>::Front() {
	const size_t current_head = _head;
	const size_t current_tail = _tail;
	if (current_head == current_tail) {
		return nullptr;
	}
	return &_buffer[current_head];
}

template<typename T>
const T* SPSCQueue<T>::PopPtr() {
	const size_t current_head = _head;
	const size_t current_tail = _tail;
	MemoryBarrier();
	if(current_head == current_tail) return nullptr;
	T* item = &_buffer[current_head];
	_head = (current_head + 1) % _capacity;
	return item;
}

#pragma once 

#include <wtypes.h>
#include <intrin.h>

template<typename T>
class SPMCQueue {
private:
	alignas(64) volatile size_t _head { 0 }; // Consumer Multiple
	alignas(64) volatile size_t _tail { 0 }; // Producer Single
    T* _buffer;
    size_t _capacity;

public:
    explicit SPMCQueue(size_t capacity)
        : _capacity(capacity) {
        _buffer = new T[capacity];
    }

    ~SPMCQueue() {
        delete[] _buffer;
    }

    bool Push(const T& item);
    bool Pop(T& item); // Several Consumers Pop 
};

template<typename T>
bool SPMCQueue<T>::Push(const T& item) {
    size_t current_tail = _tail;
    size_t next_tail = (current_tail + 1) % _capacity;

    size_t current_head = _head;
    if (next_tail == current_head) {
        return false; 
    }
	MemoryBarrier(); 
    _buffer[current_tail] = item;
	MemoryBarrier(); 
	_tail = next_tail; // Producer Single No Atomics Needed
    return true;
}

template<typename T>
bool SPMCQueue<T>::Pop(T& item) {
    size_t current_tail = _tail;
    size_t current_head = InterlockedIncrement64((volatile LONG64*)&_head) - 1;

    if (current_head == current_tail) {
        return false; 
    }

    item = _buffer[current_head % _capacity];
    return true;
}

#pragma once 

#include <wtypes.h>
#include <intrin.h>

template<typename T>
class MPSCQueue {
private:
    constexpr static const size_t CACHE_LINE_SIZE = 64;
    alignas(CACHE_LINE_SIZE) volatile size_t _head { 0 }; // Consumer Single 
	alignas(CACHE_LINE_SIZE) volatile size_t _tail { 0 }; // Producer Multiple 
    T* _buffer;
    size_t _capacity;

public:
    explicit MPSCQueue(size_t capacity)
        : _capacity(capacity)
    {
        _buffer = new T[capacity];
    }

    ~MPSCQueue() {
        delete[] _buffer;
    }

    bool Push(const T& item);
    bool Pop(T& item);
};

template<typename T>
bool MPSCQueue<T>::Push(const T& item) {
    size_t current_tail = InterlockedIncrement64((volatile LONG64*)&_tail) - 1;
    size_t next_tail = current_tail % _capacity;

    size_t current_head = _head;
    if (((current_tail + 1) % _capacity) == current_head) {
		InterlockedDecrement64((volatile LONG64*)&_tail); 
        return false; 
    }
    _buffer[next_tail] = item;
    MemoryBarrier(); 
    return true;
}

template<typename T>
bool MPSCQueue<T>::Pop(T& item) {
    size_t current_head = _head;
    size_t current_tail = _tail;

    if (current_head == current_tail) {
        return false; 
    }
    size_t next_head = (current_head + 1) % _capacity;
    MemoryBarrier(); 
    item = _buffer[current_head % _capacity];
    _head = next_head;
    return true;
}